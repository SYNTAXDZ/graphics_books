
<!DOCTYPE HTML>
<html lang="fr">
  <head>
  	<title>Apprendre OpenGL</title>
  	<meta charset="UTF-8" />
	<meta content="developpez-com" name="generator">
	<meta name="description" content="Cours complet pour apprendre OpenGL moderne (v3.3 et supérieures), accompagné d'exemples simples. Une excellente ressource sur OpenGL pour débutants"/>
	<meta name="author" content="Joey de Vries"/>
	<meta name="keywords" content=""> 
  	<script type="text/javascript" src="./js/jquery-1.7.2.js"></script>
  	<link rel="shortcut icon" type="image/x-icon" href="https://www.developpez.com/template/favicon.ico" />
                                                 
    <link rel="stylesheet" type="text/css" media="screen" href="./code.css" />
  	<link rel="stylesheet" type="text/css" href="./mini-gabarit0.css" />
  	<link rel="stylesheet" type="text/css" href="./lightbox.2.51.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="./developpez-kit-generation.css" />
    

	
    <!--[if IE 9]><link rel="stylesheet" type="text/css" href="./ie9.css" /><![endif]-->
    <!--[if IE 8]><link rel="stylesheet" type="text/css" href="./ie8.css" /><![endif]-->
    <!--[if lt IE 9]><link rel="stylesheet" type="text/css" href="./ie.css" /><![endif]-->
    <!--[if IE 7]><link rel="stylesheet" type="text/css" href="./ie7.css" /><![endif]-->
    <!--[if lte IE 6]><link rel="stylesheet" type="text/css" href="./ie6.css" /><![endif]-->
    <!--[if lt IE 9]><script type="text/javascript" src="./js/html5_ie.js"></script><![endif]-->
 
    <script type="text/javascript" src="http://www.developpez.com/template/kit/mathjax-dvp/MathJax.js?config=TeX-AMS-MML_HTMLorMML&locale=fr"></script>
    <script type="text/javascript" src="./js/developpez-kit-generation.js"></script>
    <script type="text/javascript" src="./js/fonctions-kit.js"></script>
    <script type="text/javascript" src="./js/lightbox.2.51.js"></script>
    <script type="text/javascript" src="./js/LecteurSWF.js"></script>

  </head>
  <body>
    <header class="layout">
      <div id="quicknav">	
        <nav>	
          <ul>
        		<li>
        			<a style="color: #B7D0ED;" href="https://www.developpez.net/forums/">Forums</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://general.developpez.com/cours/">Tutoriels</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://magazine.developpez.com/">Magazine</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://general.developpez.com/faq/">FAQs</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://blog.developpez.com/">Blogs</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://projets.developpez.com/">Projets</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://chat.developpez.com/">Chat</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://www.developpez.com/newsletter/">Newsletter</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://etudes.developpez.com/">Études</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://emploi.developpez.com/">Emploi</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://club.developpez.com/">Club</a>
        		</li>
        		<li>
        			<a style="color: #B7D0ED;" href="https://club.developpez.com/contacts/">Contacts</a>
        		</li>
        	</ul>
        </nav>
      </div>
    </header>
    <article  class="ArticleComplet" itemscope itemtype="http://schema.org/Article">
      <meta itemprop="genre" content="informatique"/>
      <meta itemprop="inLanguage" content="fr-FR"/>	

		<br/><header class="EnteteTitres">
<h1 class="titre-article" itemprop="name">Apprendre OpenGL moderne </h1>
<h2 class="soustitre-article">
    <b>Septième partie : mise en pratique </b>
  </h2>
</header><nav class="nav-sommaire ArticleHorsLigne"><header><h1 class="TitreHeader StopArrondi ToggleGecko">Table des mati&egrave;res<img class="ToggleImgPlier" title="Plier" alt="Plier" src="./images/fleche-haut-bleue.png"/><img class="ToggleImgDeplier" title="Déplier" alt="Déplier" style="display:none;" src="./images/fleche-bas-bleue.png"/></h1></header><ul id="nav_sommaire_ul_principal" class="nav-sommaire-ul">
  
	
  
  
  
  
  
  
  
  <li><a class="summaryIndent0" href="#LI">I. Débogage</a><ul class="nav-sommaire-ul IndentationI">
      
      
      
      <li><a class="summaryIndent1" href="#LI-A">I-A. glGetError()</a></li>
      <li><a class="summaryIndent1" href="#LI-B">I-B. Extension debug output</a><ul class="nav-sommaire-ul IndentationI-B">
        
        
        
        
        <li><a class="summaryIndent2" href="#LI-B-1">I-B-1. Sortie de débogage avec GLFW</a></li>
        <li><a class="summaryIndent2" href="#LI-B-2">I-B-2. Filtrer la sortie de débogage</a></li>
        <li><a class="summaryIndent2" href="#LI-B-3">I-B-3. Retrouver l’origine de l’erreur</a></li>
        <li><a class="summaryIndent2" href="#LI-B-4">I-B-4. Affichages personnalisés des erreurs </a></li>
      </ul></li>
      <li><a class="summaryIndent1" href="#LI-C">I-C. Déboguer les sorties des shaders</a></li>
      <li><a class="summaryIndent1" href="#LI-D">I-D. Compilateur GLSL de référence</a></li>
      <li><a class="summaryIndent1" href="#LI-E">I-E. Affichage d’un tampon de rendu</a></li>
      <li><a class="summaryIndent1" href="#LI-F">I-F. Logiciel externe de débogage</a><ul class="nav-sommaire-ul IndentationI-F">
        
        
        
        <li><a class="summaryIndent2" href="#LI-F-1">I-F-1. RenderDoc</a></li>
        <li><a class="summaryIndent2" href="#LI-F-2">I-F-2. CodeXL</a></li>
        <li><a class="summaryIndent2" href="#LI-F-3">I-F-3. NVIDIA Nsight</a></li>
      </ul></li>
      <li><a class="summaryIndent1" href="#LI-G">I-G. Ressources supplémentaires</a></li>
      <li><a class="summaryIndent1" href="#LI-H">I-H. Remerciements</a></li>
    </ul></li>
  
</ul></nav><section class="ArticleHorsLigne"><section class="articleBody" itemprop="articleBody"><div class="cachee"><div class="barreNavigation"><hr class="hr-separation"/><a class="lientelechargement" href="sommaire.html"><img title="Page précédente" alt="précédent" src="./images/kitprecedent.png"/></a><a class="lientelechargement" href="sommaire.html"><img title="Revenir au sommaire" alt="sommaire" src="./images/kitsommaire.png"/></a><a class="lientelechargement" href="affichage-de-texte.html"><img alt="suivant" title="Page suivante" src="./images/kitsuivant.png"/></a><hr class="hr-separation"/></div></div>
  
	
  
  
  
  
  
  
  
  
		<h1 class="TitreSection0" id="LI">I. Débogage<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h1><div class="BlocSection0">
      
      <p>La programmation graphique est très amusante, mais peut aussi être source de frustration quand quelque chose ne donne pas le résultat escompté, voire pas de résultat du tout ! Afficher tout ce que l’on veut implique de manipuler des pixels et il peut s’avérer difficile de trouver la cause d’une erreur lorsque tout ne se passe pas comme prévu. Déboguer ce genre d’erreurs visuelles est différent de ce que vous avez l’habitude de faire en cherchant les erreurs CPU. On ne dispose pas de console pour afficher du texte, pas de points d’arrêt pour examiner le code GLSL et pas d’outil pour examiner l’exécution sur le GPU. </p>
      <p>Dans ce tutoriel, nous verrons plusieurs techniques et astuces pour déboguer un programme OpenGL. Ce n’est pas si difficile et acquérir ces techniques sera payant à long terme.</p>
      
		<h2 class="TitreSection1" id="LI-A">I-A. glGetError()<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <p>Dès que vous utilisez OpenGL incorrectement (comme configurer un tampon sans l’avoir lié), ce sera noté et cela positionnera un ou plusieurs indicateurs d’erreurs en arrière-plan. Vous pourrez récupérer ces informations en utilisant la fonction <span class="codeinline">glGetError()</span> qui teste ces indicateurs et retourne un code d’erreur si OpenGL a été malmené. </p>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e219">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e219" onclick="selectionCode('contenuCoded0e219', 'IdTitreCode-d0e219');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e219" class="contenuCode">GLenum glGetError();</code></pre></div>
        <p>Lors de l’appel, cette fonction retourne soit un code d’erreur ou pas d’erreur du tout. Ces codes d’erreur sont listés ci-dessous :</p>
        <div class="TextAlign-center"><table class="tableau" style="border-width:0px;">
          <tr>
            <td class="colonne" style="">
              <p>Flag</p>
            </td>
            <td class="colonne" style="">
              <p>Code</p>
            </td>
            <td class="colonne" style="">
              <p>Description</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_NO_ERROR</span> </p>
            </td>
            <td class="colonne" style="">
              <p>0</p>
            </td>
            <td class="colonne" style="">
              <p>Pas d’erreur depuis le dernier appel à <span class="codeinline">glGetError()</span>.</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_INVALID_ENUM</span> </p>
            </td>
            <td class="colonne" style="">
              <p>1280</p>
            </td>
            <td class="colonne" style="">
              <p>Positionné si une énumération passée en paramètre est invalide.</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_INVALID_VALUE</span> </p>
            </td>
            <td class="colonne" style="">
              <p>1281</p>
            </td>
            <td class="colonne" style="">
              <p>Positionné si une valeur passée en paramètre est invalide.</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_INVALID_OPERATION</span> </p>
            </td>
            <td class="colonne" style="">
              <p>1282</p>
            </td>
            <td class="colonne" style="">
              <p>Positionné si l’état d’une commande est illégal compte tenu des paramètres passés.</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_STACK_OVERFLOW</span> </p>
            </td>
            <td class="colonne" style="">
              <p>1283</p>
            </td>
            <td class="colonne" style="">
              <p>Positionné si placer un objet sur la pile provoque un dépassement.</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_STACK_UNDERFLOW</span> </p>
            </td>
            <td class="colonne" style="">
              <p>1284</p>
            </td>
            <td class="colonne" style="">
              <p>Positionné si on essaie de retirer un objet d’une pile alors qu’elle est vide.</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_OUT_OF_MEMORY</span> </p>
            </td>
            <td class="colonne" style="">
              <p>1285</p>
            </td>
            <td class="colonne" style="">
              <p>Positionné si une allocation mémoire est impossible.</p>
            </td>
          </tr>
          <tr>
            <td class="colonne" style="">
              <p><span class="italique">GL_INVALID_FRAMEBUFFER_OPERATION</span> </p>
            </td>
            <td class="colonne" style="">
              <p>1286</p>
            </td>
            <td class="colonne" style="">
              <p>Positionné en cas de lecture ou d’écriture dans un tampon de rendu incomplet. </p>
            </td>
          </tr>
        </table></div>
        <p>Dans la documentation des fonctions OpenGL, vous pourrez toujours trouver les codes d’erreur qu’une fonction génère au moment où l’erreur se produit. Par exemple, si vous regardez la documentation de la fonction <span class="codeinline">glBindTexture()</span>, vous trouverez tous les codes d’erreur dans la section <span class="italique"><span style="color:#3333ff;">Errors</span></span>.</p>
        <p>Dès qu’un indicateur d’erreur est positionné, plus aucune erreur ne sera enregistrée. De plus, l’appel de <span class="codeinline">glGetError()</span> efface tous les indicateurs d’erreurs (ou seulement un dans un système distribué, voir la note ci-dessous). Cela implique que si vous appelez <span class="codeinline">glGetError()</span> à la fin d’un rendu et que vous trouvez une erreur, vous ne pouvez pas en conclure que c’était la seule erreur et de plus, la source de l’erreur peut se trouver n’importe où dans la boucle de rendu. </p>
        <div class="imgtext-info">
          <p>Noter que si OpenGL s’exécute de façon distribuée, comme cela est souvent le cas sur les systèmes X11, d’autres codes d’erreur utilisateur peuvent encore être générés tant qu’ils ont différents indicateurs. L’appel à <span class="codeinline">glGetError()</span> n’efface alors que l’un des indicateurs et non pas tous. De ce fait, il est recommandé d’appeler <span class="codeinline">glGetError()</span> à l’intérieur d’une boucle.</p>
        </div>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e467">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e467" onclick="selectionCode('contenuCoded0e467', 'IdTitreCode-d0e467');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e467" class="contenuCode">glBindTexture(GL_TEXTURE_2D, tex);
<code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> glGetError() <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl; <code class="cpp_comment2">// retourne 0 (pas d’erreur)</code>

glTexImage2D(GL_TEXTURE_3D, <code class="cpp_digit">0</code>, GL_RGB, <code class="cpp_digit">512</code>, <code class="cpp_digit">512</code>, <code class="cpp_digit">0</code>, GL_RGB, GL_UNSIGNED_BYTE, data);
<code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> glGetError() <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl; <code class="cpp_comment2">// retourne 1280 (énumération invalide)</code>
Textures(<code class="cpp_operator">-</code><code class="cpp_digit">5</code>, textures);
<code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> glGetError() <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl; <code class="cpp_comment2">// retourne 1281 (valeur incorrecte)</code>
<code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> glGetError() <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl; <code class="cpp_comment2">// retourne 0 (pas d’erreur)</code></code></pre></div>
        <p>L’intérêt majeur de <span class="codeinline">glGetError()</span> est de permettre la localisation précise des erreurs et aussi de valider l’utilisation correcte d’OpenGL. Supposons que vous obteniez un écran noir sans savoir d’où vient le problème : le tampon d’affichage est-il bien établi ? Aurais-je oublié de lier une texture ? En appelant <span class="codeinline">glGetError()</span> vous pouvez trouver rapidement le premier endroit où une erreur apparaît et donc ce qui pose un problème.</p>
        <p>Par défaut, <span class="codeinline">glGetError()</span> n’affiche que les codes d’erreur, ce qui n’est pas facile à comprendre, à moins d’avoir mémorisé ces codes. Il est souvent plus pratique d’utiliser une petite fonction utilitaire pour afficher un message d’erreur à l’endroit où la vérification est effectuée :</p>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e561">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e561" onclick="selectionCode('contenuCoded0e561', 'IdTitreCode-d0e561');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e561" class="contenuCode">GLenum glCheckError_(<code class="cpp_keyword1">const</code> <code class="cpp_keyword3">char</code> <code class="cpp_operator">*</code>file, <code class="cpp_keyword3">int</code> line)
<code class="cpp_operator">{</code>
    GLenum errorCode;
    <code class="cpp_keyword1">while</code> ((errorCode <code class="cpp_operator">=</code> glGetError()) <code class="cpp_operator">!=</code> GL_NO_ERROR)
    <code class="cpp_operator">{</code>
        <code class="cpp_function">std::</code>string error;
        <code class="cpp_keyword1">switch</code> (errorCode)
        <code class="cpp_operator">{</code>
            <code class="cpp_keyword1">case</code> GL_INVALID_ENUM: error <code class="cpp_operator">=</code> <code class="cpp_literal1">"INVALID_ENUM"</code>; <code class="cpp_keyword1">break</code>;
            <code class="cpp_keyword1">case</code> GL_INVALID_VALUE: error <code class="cpp_operator">=</code> <code class="cpp_literal1">"INVALID_VALUE"</code>; <code class="cpp_keyword1">break</code>;
            <code class="cpp_keyword1">case</code> GL_INVALID_OPERATION: error <code class="cpp_operator">=</code> <code class="cpp_literal1">"INVALID_OPERATION"</code>; <code class="cpp_keyword1">break</code>;
            <code class="cpp_keyword1">case</code> GL_STACK_OVERFLOW: error <code class="cpp_operator">=</code> <code class="cpp_literal1">"STACK_OVERFLOW"</code>; <code class="cpp_keyword1">break</code>;
            <code class="cpp_keyword1">case</code> GL_STACK_UNDERFLOW:  error <code class="cpp_operator">=</code> <code class="cpp_literal1">"STACK_UNDERFLOW"</code>; <code class="cpp_keyword1">break</code>;
            <code class="cpp_keyword1">case</code> GL_OUT_OF_MEMORY: error <code class="cpp_operator">=</code> <code class="cpp_literal1">"OUT_OF_MEMORY"</code>; <code class="cpp_keyword1">break</code>;
            <code class="cpp_keyword1">case</code> GL_INVALID_FRAMEBUFFER_OPERATION: error <code class="cpp_operator">=</code> <code class="cpp_literal1">"INVALID_FRAMEBUFFER_OPERATION"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_operator">}</code>
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> error <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">" | "</code> <code class="cpp_operator">&lt;&lt;</code> file <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">" ("</code> <code class="cpp_operator">&lt;&lt;</code> line <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">")"</code> <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl;
    <code class="cpp_operator">}</code>
    <code class="cpp_keyword1">return</code> errorCode;
<code class="cpp_operator">}</code>
<code class="cpp_literal3">#define glCheckError() glCheckError_(__FILE__, __LINE__)</code></code></pre></div>
        <p>Si vous n’êtes pas familier des directives du préprocesseur, <span class="codeinline">__FILE__</span> et <span class="codeinline">__LINE__</span> sont remplacés lors de la compilation par le nom du fichier et la ligne en cours. Si l’on utilise un certain nombre de ces appels <span class="codeinline">glCheckError()</span>, mieux vaut savoir précisément lequel affiche l’erreur.</p>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e746">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e746" onclick="selectionCode('contenuCoded0e746', 'IdTitreCode-d0e746');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e746" class="contenuCode">glBindBuffer(GL_VERTEX_ARRAY, vbo);
glCheckError();</code></pre></div>
        <p>Cela produira l’affichage suivant : </p>
        <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_glgeterror.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_glgeterror.png" alt="Sortie de glGetError() lors d'un débogage OpenGL." width="550" height="69"/></a></figure></div>
        <p>Il nous paraît <b>important</b> de signaler que GLEW renferme un bogue ancien : lors de l’appel <span class="codeinline">glewInit()</span>, la fonction <span class="codeinline">glGetError()</span> positionne l’indicateur d’erreur <span class="codeinline">GL_INVALID_ENUM</span> et retourne donc un code d’erreur qui peut vous tromper. Pour éviter cela, on peut simplement appeler <span class="codeinline">glGetError()</span> pour effacer l’indicateur d’erreur :</p>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e772">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e772" onclick="selectionCode('contenuCoded0e772', 'IdTitreCode-d0e772');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e772" class="contenuCode">glewInit();
glGetError();</code></pre></div>
        <p><span class="codeinline">glGetError()</span> ne donne pas beaucoup d’informations sur la cause de l’erreur, mais cela vous aidera à localiser des fautes de frappe et à trouver où votre code est erroné : c’est un outil de débogage assez simple, mais efficace.</p>
      </div>
      
		<h2 class="TitreSection1" id="LI-B">I-B. Extension debug output<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <p>Un outil moins courant, mais plus pratique que <span class="codeinline">glGetError()</span> est l’extension d’OpenGL nommée <b>debug output</b> (sortie de débogage) qui fait partie d’OpenGL depuis la version 4.3. Avec cette extension, OpenGL renverra lui-même une erreur et un message d’avertissement à l’utilisateur, bien plus détaillé que <span class="codeinline">glCheckError()</span>. Non seulement cela donne plus d’informations, mais vous pouvez localiser les erreurs plus précisément en utilisant le support d’un débogueur.</p>
        <div class="imgtext-info">
          <p><span style="color:#3333ff;">La sortie de débogage</span> fait partie du noyau d’OpenGL depuis la version 4.3, ce qui rend cette fonctionnalité disponible sur toute machine disposant de la version 4.3 ou ultérieure. Si ce n’est pas le cas, cette fonctionnalité peut être obtenue avec l’extension <span class="italique">ARB_debug_output</span> ou bien <span class="italique">AMD_debug_output</span>. Cela semble ne pas fonctionner sur OS X (je ne l’ai pas testé moi-même, dîtes-moi si je me trompe).</p>
        </div>
        <p>Pour utiliser la sortie de débogage, il faut obtenir un contexte spécifique auprès d’OpenGL lors du processus d’initialisation. Ce processus dépend de votre système de fenêtrage ; ici, nous utilisons GLFW, mais vous pouvez trouver l’information nécessaire pour d’autres systèmes dans les ressources additionnelles à la fin de ce chapitre.</p>
        
		<h3 class="TitreSection2" id="LI-B-1">I-B-1. Sortie de débogage avec GLFW<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h3><div class="BlocSection2">
          
          <p>Obtenir un contexte pour la sortie de débogage est très facile avec GLFW, la seule chose à faire est de le demander, avant de faire appel à <span class="codeinline">glfwCreateWindow()</span> : </p>
          <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e826">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e826" onclick="selectionCode('contenuCoded0e826', 'IdTitreCode-d0e826');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e826" class="contenuCode">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code></pre></div>
          <p>Après avoir initialisé GLFW, on devrait disposer d’un contexte de débogage si l’on utilise OpenGL 4.3 ou plus, ou sinon, il faut espérer que le système peut fournir un contexte de débogage. Enfin, on peut obtenir un contexte de débogage avec les extensions d’OpenGL.</p>
          <div class="imgtext-info">
            <p>Utiliser OpenGL en mode debug peut ralentir significativement l’exécution, il faudra penser à le supprimer si vous travaillez l’optimisation ou la version finale de l’application.</p>
          </div>
          <p>Pour vérifier que le contexte de débogage a été initialisé avec succès, on peut interroger OpenGL :</p>
          <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e841">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e841" onclick="selectionCode('contenuCoded0e841', 'IdTitreCode-d0e841');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e841" class="contenuCode">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, <code class="cpp_operator">&amp;</code>flags);
<code class="cpp_keyword1">if</code> (flags <code class="cpp_operator">&amp;</code> GL_CONTEXT_FLAG_DEBUG_BIT)
<code class="cpp_operator">{</code>
    <code class="cpp_comment2">// initialisation de la sortie de débogage</code>
<code class="cpp_operator">}</code></code></pre></div>
          <p><span style="color:#3333ff;">La sortie de débogage</span> fonctionne de cette façon : on définit une fonction callback d’enregistrement d’erreur (comme les fonctions callback pour les entrées utilisateur) et nous traitons les données d’erreur dans la fonction callback comme bon nous semble. Dans notre cas, nous afficherons un message d’erreur sur la console. Ci-dessous un prototype de fonction callback qu’OpenGL attend pour la sortie de débogage : </p>
          <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e866">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e866" onclick="selectionCode('contenuCoded0e866', 'IdTitreCode-d0e866');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e866" class="contenuCode"><code class="cpp_keyword1">void</code> APIENTRY glDebugOutput(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, <code class="cpp_keyword1">const</code> GLchar <code class="cpp_operator">*</code>message, <code class="cpp_keyword1">void</code> <code class="cpp_operator">*</code>userParam);</code></pre></div>
          <p>Noter que dans certaines implémentations d’OpenGL, le dernier paramètre doit être de type <span class="codeinline">const void*</span> au lieu de <span class="codeinline">void*</span>.</p>
          <p>Compte tenu du nombre important de données à traiter, on pourra créer un outil pratique d’affichage des erreurs comme ceci :</p>
          <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e895">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e895" onclick="selectionCode('contenuCoded0e895', 'IdTitreCode-d0e895');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e895" class="contenuCode"><code class="cpp_keyword1">void</code> APIENTRY glDebugOutput(GLenum source,
                            GLenum type,
                            GLuint id,
                            GLenum severity,
                            GLsizei length,
                            <code class="cpp_keyword1">const</code> GLchar <code class="cpp_operator">*</code>message,
                            <code class="cpp_keyword1">void</code> <code class="cpp_operator">*</code>userParam)
<code class="cpp_operator">{</code>
    <code class="cpp_comment2">// on ignore les codes ou avertissements non significatifs</code>
    <code class="cpp_keyword1">if</code>(id <code class="cpp_operator">==</code> <code class="cpp_digit">131169</code> <code class="cpp_operator">||</code> id <code class="cpp_operator">==</code> <code class="cpp_digit">131185</code> <code class="cpp_operator">||</code> id <code class="cpp_operator">==</code> <code class="cpp_digit">131218</code> <code class="cpp_operator">||</code> id <code class="cpp_operator">==</code> <code class="cpp_digit">131204</code>)
        <code class="cpp_keyword1">return</code>;
    <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"---------------"</code> <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl;
    <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Debug message ("</code> <code class="cpp_operator">&lt;&lt;</code> id <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"): "</code> <code class="cpp_operator">&lt;&lt;</code>  message <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl;
    <code class="cpp_keyword1">switch</code> (source)
    <code class="cpp_operator">{</code>
        <code class="cpp_keyword1">case</code> GL_DEBUG_SOURCE_API:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Source: API"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SOURCE_WINDOW_SYSTEM:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Source: Window System"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SOURCE_SHADER_COMPILER:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Source: Shader Compiler"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SOURCE_THIRD_PARTY:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Source: Third Party"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SOURCE_APPLICATION:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Source: Application"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SOURCE_OTHER:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Source: Other"</code>; <code class="cpp_keyword1">break</code>;
    <code class="cpp_operator">}</code>
    <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl;
    <code class="cpp_keyword1">switch</code> (type)
    <code class="cpp_operator">{</code>
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_ERROR:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Error"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Deprecated Behaviour"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Undefined Behaviour"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_PORTABILITY:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Portability"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_PERFORMANCE:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Performance"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_MARKER:
       <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Marker"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_PUSH_GROUP:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Push Group"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_POP_GROUP:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Pop Group"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_TYPE_OTHER:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Type: Other"</code>; <code class="cpp_keyword1">break</code>;
    <code class="cpp_operator">}</code>
    <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl;
    <code class="cpp_keyword1">switch</code> (severity)
    <code class="cpp_operator">{</code>
        <code class="cpp_keyword1">case</code> GL_DEBUG_SEVERITY_HIGH:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Severity: high"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SEVERITY_MEDIUM:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Severity: medium"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SEVERITY_LOW:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Severity: low"</code>; <code class="cpp_keyword1">break</code>;
        <code class="cpp_keyword1">case</code> GL_DEBUG_SEVERITY_NOTIFICATION:
        <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_literal1">"Severity: notification"</code>; <code class="cpp_keyword1">break</code>;
    <code class="cpp_operator">}</code>
    <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl;
    <code class="cpp_function">std::</code>cout <code class="cpp_operator">&lt;&lt;</code> <code class="cpp_function">std::</code>endl;
<code class="cpp_operator">}</code></code></pre></div>
          <p>Dès lors que le pilote détectera une erreur OpenGL, la fonction callback sera appelée, et nous afficherons un message d’erreur intéressant. Noter que nous ignorons certains codes d’erreur qui ne sont pas d’un intérêt notable (comme 131185 avec les pilotes NVIDIA qui dit qu’un tampon a bien été créé).</p>
          <p>Maintenant que nous avons notre fonction callback, il est temps d’initialiser la sortie de débogage :</p>
          <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e1355">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e1355" onclick="selectionCode('contenuCoded0e1355', 'IdTitreCode-d0e1355');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e1355" class="contenuCode"><code class="cpp_keyword1">if</code> (flags <code class="cpp_operator">&amp;</code> GL_CONTEXT_FLAG_DEBUG_BIT)
<code class="cpp_operator">{</code>
    glEnable(GL_DEBUG_OUTPUT);
    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
    glDebugMessageCallback(glDebugOutput, <code class="cpp_literal2">nullptr</code>);
    glDebugMessageControl(GL_DONT_CARE,
                          GL_DONT_CARE,
                          GL_DONT_CARE,
                          <code class="cpp_digit">0</code>, <code class="cpp_literal2">nullptr</code>, GL_TRUE);
<code class="cpp_operator">}</code></code></pre></div>
          <p>Nous demandons à OpenGL d’activer la sortie de débogage. L’appel <span class="codeinline">glEnable(GL_DEBUG_OUTPUT)</span> demande à OpenGL d’appeler directement la fonction callback lorsqu’une erreur se produit.</p>
        </div>
        
		<h3 class="TitreSection2" id="LI-B-2">I-B-2. Filtrer la sortie de débogage<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h3><div class="BlocSection2">
          
          <p>Avec <span class="codeinline">glDebugMessageControl()</span> vous pouvez filtrer le type d’erreur dont vous voulez être averti. Dans notre cas, nous avons décidé de n’appliquer aucun filtre sur la source, le type ou la gravité de l’erreur. Si nous voulions n’afficher que les messages provenant de l’API OpenGL, qui sont des erreurs, et qui sont graves, on aurait configuré les choses comme ceci :</p>
          <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e1395">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e1395" onclick="selectionCode('contenuCoded0e1395', 'IdTitreCode-d0e1395');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e1395" class="contenuCode">glDebugMessageControl(GL_DEBUG_SOURCE_API,
                      GL_DEBUG_TYPE_ERROR,
                      GL_DEBUG_SEVERITY_HIGH,
                      <code class="cpp_digit">0</code>, <code class="cpp_literal2">nullptr</code>, GL_TRUE);</code></pre></div>
          <p>En fonction de votre configuration et en supposant que vous avez un contexte qui supporte la sortie de débogage<span style="color:#3333ff;">,</span> chaque commande OpenGL incorrecte vous affichera un message utile et détaillé :</p>
          <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_debug_output.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_debug_output.png" alt="Sortie du contexte de débogage d'OpenGL." width="550" height="93"/></a></figure></div>
        </div>
        
		<h3 class="TitreSection2" id="LI-B-3">I-B-3. Retrouver l’origine de l’erreur<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h3><div class="BlocSection2">
          
          <p>Un autre avantage de la sortie de débogage est de pouvoir facilement connaître la ligne exacte où s’est produite l’erreur. En plaçant un point d’arrêt dans <span class="codeinline">DebugOutput()</span> sur un type d’erreur particulier (ou bien au début de la fonction si cela vous va bien), le débogueur interceptera l’erreur et vous pourrez remonter la pile des appels jusqu’à la fonction ayant produit l’erreur :</p>
          <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_debug_output_breakpoint.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_debug_output_breakpoint.png" alt="Définition d'un point d'arrêt et utilisation de la liste des appels avec OpenGL pour obtenir la ligne provoquant une erreur." width="550" height="236"/></a></figure></div>
          <p>Il faut intervenir manuellement, mais si vous savez à peu près ce que vous cherchez, c’est extrêmement utile de déterminer rapidement quel appel a produit l’erreur.</p>
        </div>
        
		<h3 class="TitreSection2" id="LI-B-4">I-B-4. Affichages personnalisés des erreurs <a class="HautPage" href="#" title="Haut de page">&#9650;</a></h3><div class="BlocSection2">
          
          <p>En plus de la lecture simple des messages, vous pouvez aussi placer les messages de votre choix dans le système de la sortie de débogage : </p>
          <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e1438">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e1438" onclick="selectionCode('contenuCoded0e1438', 'IdTitreCode-d0e1438');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e1438" class="contenuCode">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <code class="cpp_digit">0</code>,  GL_DEBUG_SEVERITY_MEDIUM, <code class="cpp_operator">-</code><code class="cpp_digit">1</code>, <code class="cpp_literal1">"votre message d’erreur ici"</code>);</code></pre></div>
          <p>Cela est très utile si vous vous intégrez dans une autre application ou un autre code OpenGL qui utilise aussi un contexte supportant la sortie de débogage. D’autres développeurs peuvent ainsi rapidement signaler un bogue qui se produit dans votre propre code.</p>
          <p>Pour résumer, la sortie de débogage (si vous pouvez l’utiliser) est extrêmement utile pour trouver rapidement les erreurs, cet outil mérite d’être installé, il vous fera gagner beaucoup de temps de développement. Vous trouverez une copie du code <a class="lienArticle https" href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/1.debugging/debugging.cpp" target="_blank">ici</a>, configuré avec <span class="codeinline">glGetError()</span> et la sortie de débogage, voyez si vous pouvez retrouver toutes les erreurs.</p>
        </div>
      </div>
      
		<h2 class="TitreSection1" id="LI-C">I-C. Déboguer les sorties des shaders<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <p>Quant à GLSL, nous ne disposons malheureusement pas d’une fonction comme <span class="codeinline">glGetError()</span> ni de la possibilité de placer des points d’arrêt dans le code d’un shader. Si vous obtenez un écran tout noir ou un effet visuel complètement faux, il est assez difficile de savoir ce qui ne fonctionne pas dans un shader. Les erreurs de compilation sont bien signalées, mais trouver les erreurs de logique est une autre histoire. </p>
        <p>Une astuce souvent utilisée pour déboguer un shader consiste à évaluer toutes les variables d’un programme shader en les envoyant directement en sortie du fragment shader. En substituant les variables directement aux couleurs produites par le fragment shader, on peut souvent obtenir des informations intéressantes en inspectant les résultats visuellement. Par exemple, supposons que l’on veuille vérifier les normales d’un modèle, on peut les passer (transformées ou non) du vertex shader au fragment shader et on les sortira comme suit :</p>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e1480">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e1480" onclick="selectionCode('contenuCoded0e1480', 'IdTitreCode-d0e1480');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e1480" class="contenuCode"><code class="glsl_keyword2">#</code><code class="glsl_markup">version</code><code class="glsl_keyword2"> </code><code class="glsl_digit">330</code><code class="glsl_keyword2"> core</code>
<code class="glsl_keyword1">out</code> <code class="glsl_keyword4">vec4</code> FragColor;
<code class="glsl_keyword1">in</code> <code class="glsl_keyword4">vec3</code> Normal;
[...]
<code class="glsl_keyword4">void</code> <code class="glsl_function">main</code><code class="glsl_operator">(</code>)
<code class="glsl_operator">{</code>
    […]
    FragColor.rgb <code class="glsl_operator">=</code> Normal;
    FragColor.a <code class="glsl_operator">=</code> <code class="glsl_digit">1</code>.<code class="glsl_digit">0f</code>;
<code class="glsl_operator">}</code></code></pre></div>
        <p>En sortant une variable (qui n’est pas une couleur) comme une couleur, on peut visualiser si la variable semble correcte. Si par exemple le résultat est complètement noir, il est clair que les normales ne sont pas correctement passées aux shaders ; et si elles s’affichent, il est facile de vérifier si elles semblent correctes ou non :</p>
        <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_glsl_output.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_glsl_output.png" alt="L'image du modèle 3D avec les normales affichées avec la sortie du fragment shader pour déboguer l'application OpenGL." width="410" height="325"/></a></figure></div>
        <p>On voit que les normales semblent correctes, les normales pointant vers la droite sont rouges, celles pointant vers l’avant sont bleues, et celles vers le haut sont vertes. </p>
        <p>Cette approche peut être étendue à tout type de variable à tester. Si vous suspectez un problème dans un shader, essayez d’afficher certains résultats sous forme de couleur.</p>
      </div>
      
		<h2 class="TitreSection1" id="LI-D">I-D. Compilateur GLSL de référence<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <p>Chaque pilote graphique a ses propres manies et bizarreries. Par exemple, les pilotes NVIDIA sont assez relax et négligents quant aux spécifications, tandis que les pilotes ATI/AMD sont plus rigoureux et tendent à renforcer la spécification d’OpenGL (ce qui me semble la bonne approche). Le problème, c’est qu’un shader peut fonctionner sur une machine et pas sur une autre, du fait de pilotes différents.</p>
        <p>Avec quelques années d’expérience, vous pourrez peut-être apprendre les différences mineures entre les constructeurs de GPU, mais si vous voulez être sûr que votre code fonctionne sur toutes les machines, vous pouvez le tester en utilisant le <a class="lienArticle https" href="https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/" target="_blank">compilateur GLSL de référence</a>. Vous pouvez télécharger le binaire « <span style="color:#009900;">GLSL lang validator </span>» <a class="lienArticle https" href="https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/" target="_blank">ici</a> ou le code source complet <a class="lienArticle https" href="https://github.com/KhronosGroup/glslang" target="_blank">ici</a>. </p>
        <p>Avec « <span style="color:#00cc00;">GLSL lang validator </span>», vous pouvez facilement vérifier le code de vos shaders en passant le code de votre shader comme premier argument. Sachez que « <span style="color:#00cc00;">GLSL lang validator </span>» détermine le type de shader au moyen d’une liste d’extensions fixes :</p>
        <ul class="ListeDVP">
          <li><span class="codeinline">.vert</span> : vertex shader. </li>
          <li><span class="codeinline">.frag</span> : fragment shader. </li>
          <li><span class="codeinline">.geom</span> : geometry shader. </li>
          <li><span class="codeinline">.tesc</span> : tessellation control shader. </li>
          <li><span class="codeinline">.tese</span> : tessellation evaluation shader. </li>
          <li><span class="codeinline">.comp</span> : compute shader. </li>
        </ul>
        <p>Exécuter le compilateur de référence de GLSL est très simple :</p>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e1610">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e1610" onclick="selectionCode('contenuCoded0e1610', 'IdTitreCode-d0e1610');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e1610" class="contenuCode">glsllangvalidator shaderFile.vert</code></pre></div>
        <p>S’il n’y a pas d’erreur, il ne retourne rien. Si un vertex shader comporte une erreur, on obtiendra ce genre d’affichage : </p>
        <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_glsl_reference_compiler.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_glsl_reference_compiler.png" alt="Sortie du compilateur GLSL de référence (GLSL lang validator) en OpenGL." width="550" height="171"/></a></figure></div>
        <p>Il ne vous donnera pas les différences subtiles entre les versions des compilateurs GLSL d’AMD, NVIDIA ou Intel, ni ne vous aidera à complètement déboguer vos shaders, mais au moins vous aidera à les comparer aux spécifications officielles de GLSL.</p>
      </div>
      
		<h2 class="TitreSection1" id="LI-E">I-E. Affichage d’un tampon de rendu<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <p>Une autre astuce utile pour déboguer consiste à afficher le contenu d’un tampon de rendu (voir chapitre 26) dans une zone prédéfinie de votre application OpenGL. Vous allez très souvent utiliser ces tampons de rendu nommés « framebuffers », et comme l’essentiel de leur rôle se déroule en arrière-plan, il est quelquefois difficile de réaliser ce qu’il s’y passe. Afficher le contenu d’un tampon de rendu dans votre application est un moyen pratique de voir rapidement si tout se passe bien. </p>
        <div class="imgtext-info">
          <p>Notons que l’affichage du contenu d’un tampon de rendu comme expliqué ici ne fonctionnera que pour le rendu dans une texture, et non pas pour les objets de tampon de rendu.</p>
        </div>
        <p>En utilisant un simple shader qui affiche une texture, on peut facilement écrire une petite fonction utilitaire pour afficher n’importe quelle texture en haut à droite de l’écran :</p>
        <div class="code_et_titre"><div class="titre_des_codes" id="IdTitreCode-d0e1639">&nbsp;<div class="selectionner_code"><span class="selectionner_code LienSelectionne" id="code-d0e1639" onclick="selectionCode('contenuCoded0e1639', 'IdTitreCode-d0e1639');">S&eacute;lectionnez</span></div></div><pre class="code_uniquement" style="overflow:auto;"><code id="contenuCoded0e1639" class="contenuCode"><code class="glsl_comment2">// vertex shader</code>
<code class="glsl_keyword2">#</code><code class="glsl_markup">version</code><code class="glsl_keyword2"> </code><code class="glsl_digit">330</code><code class="glsl_keyword2"> core</code>
<code class="glsl_keyword1">layout</code> <code class="glsl_operator">(</code>location <code class="glsl_operator">=</code> <code class="glsl_digit">0</code>) <code class="glsl_keyword1">in</code> <code class="glsl_keyword4">vec2</code> position;
<code class="glsl_keyword1">layout</code> <code class="glsl_operator">(</code>location <code class="glsl_operator">=</code> <code class="glsl_digit">1</code>) <code class="glsl_keyword1">in</code> <code class="glsl_keyword4">vec2</code> texCoords;
<code class="glsl_keyword1">out</code> <code class="glsl_keyword4">vec2</code> TexCoords;
<code class="glsl_keyword4">void</code> <code class="glsl_function">main</code><code class="glsl_operator">(</code>)
<code class="glsl_operator">{</code>
    <code class="glsl_keyword2">gl_Position</code> <code class="glsl_operator">=</code> <code class="glsl_keyword4">vec4</code><code class="glsl_operator">(</code>position, <code class="glsl_digit">0</code>.<code class="glsl_digit">0f</code>, <code class="glsl_digit">1</code>.<code class="glsl_digit">0f</code>);
    TexCoords <code class="glsl_operator">=</code> texCoords;
<code class="glsl_operator">}</code>

<code class="glsl_comment2">// fragment shader</code>
<code class="glsl_keyword2">#</code><code class="glsl_markup">version</code><code class="glsl_keyword2"> </code><code class="glsl_digit">330</code><code class="glsl_keyword2"> core</code>
<code class="glsl_keyword1">out</code> <code class="glsl_keyword4">vec4</code> FragColor;
<code class="glsl_keyword1">in</code>  <code class="glsl_keyword4">vec2</code> TexCoords;
<code class="glsl_keyword1">uniform</code> <code class="glsl_keyword4">sampler2D</code> fboAttachment;
<code class="glsl_keyword4">void</code> <code class="glsl_function">main</code><code class="glsl_operator">(</code>)
<code class="glsl_operator">{</code>
    FragColor <code class="glsl_operator">=</code> <code class="glsl_function">texture</code><code class="glsl_operator">(</code>fboAttachment, TexCoords);
<code class="glsl_operator">}</code>

<code class="glsl_keyword4">void</code> <code class="glsl_function">DisplayFramebufferTexture</code><code class="glsl_operator">(</code>GLuint textureID)
<code class="glsl_operator">{</code>
    <code class="glsl_keyword1">if</code><code class="glsl_operator">(!</code>notInitialized)
    <code class="glsl_operator">{</code>
        <code class="glsl_comment2">// initialise le shader et le VAO avec les coordonnées de sommets en espace de périphérique, en haut à droite de l’écran</code>
        […]
    <code class="glsl_operator">}</code>
     <code class="glsl_function">glActiveTexture</code><code class="glsl_operator">(</code>GL_TEXTURE0);
     <code class="glsl_function">glUseProgram</code><code class="glsl_operator">(</code>shaderDisplayFBOOutput);
     <code class="glsl_function">glBindTexture</code><code class="glsl_operator">(</code>GL_TEXTURE_2D, textureID);
     <code class="glsl_function">glBindVertexArray</code><code class="glsl_operator">(</code>vaoDebugTexturedRect);
     <code class="glsl_function">glDrawArrays</code><code class="glsl_operator">(</code>GL_TRIANGLES, <code class="glsl_digit">0</code>, <code class="glsl_digit">6</code>);
     <code class="glsl_function">glBindVertexArray</code><code class="glsl_operator">(</code><code class="glsl_digit">0</code>);
     <code class="glsl_function">glUseProgram</code><code class="glsl_operator">(</code><code class="glsl_digit">0</code>);
<code class="glsl_operator">}</code>

<code class="glsl_keyword4">int</code> <code class="glsl_function">main</code><code class="glsl_operator">(</code>)
<code class="glsl_operator">{</code>
    […]
    <code class="glsl_keyword1">while</code> <code class="glsl_operator">(!</code><code class="glsl_function">glfwWindowShouldClose</code><code class="glsl_operator">(</code>window))
    <code class="glsl_operator">{</code>
        […]
        <code class="glsl_function">DisplayFramebufferTexture</code><code class="glsl_operator">(</code>fboAttachment0);
        <code class="glsl_function">glfwSwapBuffers</code><code class="glsl_operator">(</code>window);
    <code class="glsl_operator">}</code>
<code class="glsl_operator">}</code></code></pre></div>
        <p>Ce code vous donnera une petite fenêtre sympa au coin de votre écran pour déboguer un tampon de rendu. Utile, par exemple, pour déterminer si les normales d’un rendu différé semblent correctes :</p>
        <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_fbo_output.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_fbo_output.png" alt="Affichage des FBO à des fins de débogage en OpenGL." width="412" height="325"/></a></figure></div>
        <p>On peut bien sûr étendre ce genre de fonction pour supporter le rendu de plus d’une texture. C’est un moyen rapide, mais peu orthodoxe d’obtenir un retour de ce qui se passe dans vos tampons de rendu.</p>
      </div>
      
		<h2 class="TitreSection1" id="LI-F">I-F. Logiciel externe de débogage<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <p>Quand tout ceci ne suffit pas, on peut encore utiliser un outil tiers pour aider au débogage. Ces applications externes s’insèrent souvent elles-mêmes dans les pilotes d’OpenGL et sont capables d’intercepter toutes sortes d’appels OpenGL pour vous donner un vaste tableau de données intéressantes concernant votre application. Ces outils peuvent vous aider dans de nombreux domaines comme : suivre l’utilisation des fonctions OpenGL, trouver des goulots d’étranglement, inspecter les tampons mémoire, afficher des textures et les objets attachés au tampon de rendu. Si vous travaillez sur des codes de grosses productions, ces outils procurent une aide inestimable pour votre processus de développement.</p>
        <p>J’ai listé ci-dessous, certains parmi les plus connus de ces logiciels de débogage ; essayez-les et voyez ce qui vous convient le mieux.</p>
        
		<h3 class="TitreSection2" id="LI-F-1">I-F-1. RenderDoc<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h3><div class="BlocSection2">
          
          <p>RenderDoc est un puissant outil autonome (entièrement <a class="lienArticle https" href="https://github.com/baldurk/renderdoc" target="_blank">open source</a>). Pour lancer une capture, vous spécifiez l’exécutable que vous voulez capturer et un répertoire de travail. Votre application fonctionne alors comme d’habitude, et à chaque fois que vous souhaitez inspecter un rendu particulier, vous laissez RenderDoc capturer un ou plusieurs rendus dans l’état courant de l’exécutable. Dans les rendus capturés, vous pouvez voir l’état du pipeline, toutes les commandes OpenGL, les tampons et textures en cours d’utilisation. </p>
          <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_external_renderdoc.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_external_renderdoc.png" alt="Image de RenderDoc avec une application OpenGL." width="516" height="325"/></a></figure></div>
        </div>
        
		<h3 class="TitreSection2" id="LI-F-2">I-F-2. CodeXL<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h3><div class="BlocSection2">
          
          <p><a class="lienArticle https" href="https://gpuopen.com/compute-product/codexl/" target="_blank">CodeXL</a> est un outil de débogage du GPU délivré comme autonome ou bien comme plugin de Visual Studio. CodeXL donne pas mal d’informations et permet de suivre efficacement les applications graphiques. CodeXL fonctionne avec les cartes NVIDIA et Intel, mais sans support pour déboguer OpenCL.</p>
          <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_external_codexl.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_external_codexl.png" alt="Image de CodeXL avec une application OpenGL." width="528" height="325"/></a></figure></div>
          <p>Je n’ai pas beaucoup d’expérience sur CodeXL, car je trouve RenderDoc plus facile à utiliser, mais je le mentionne, car il semble être un outil solide et développé par l’un des plus grands fabricants de GPU.</p>
        </div>
        
		<h3 class="TitreSection2" id="LI-F-3">I-F-3. NVIDIA Nsight<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h3><div class="BlocSection2">
          
          <p><a class="lienArticle https" href="https://developer.nvidia.com/nvidia-nsight-visual-studio-edition" target="_blank">Nsight</a> de NVIDIA est un outil de débogage GPU bien connu. Ce n’est pas un logiciel autonome, mais un plugin pour Visual Studio ou encore Eclipse. Le plugin Nsight est un outil incroyablement utile pour les développeurs graphiques, il présente de nombreuses statistiques sur l’utilisation du GPU et de l’état du GPU passe de rendu par passe de rendu. </p>
          <p>Dès que vous lancez votre application depuis Visual Studio (ou Eclipse) en utilisant le débogage ou le profilage, Nsight s’exécutera dans l’application elle-même. Le grand intérêt de Nsight est d’afficher une interface utilisateur au premier plan, à partir de l’application, que l’on peut utiliser pour obtenir toutes sortes d’informations sur l’application, soit pendant l’exécution, soit pendant l’analyse des passes de rendu.</p>
          <div class="div-figure"><figure class="figure-center"><a data-rel="lightbox[article]" href="./images/debugging_external_nsight.png"><img class="ImgCliquable figure-img-caption" src="./images/debugging_external_nsight.png" alt="Image de NSight avec une application OpenGL." width="550" height="324"/></a></figure></div>
          <p>Nsight est un outil très puissant qui, selon moi, est le plus performant, mais son inconvénient majeur est de ne fonctionner qu’avec les cartes NVIDIA. Si vous travaillez avec NVIDIA et (Visual Studio), cela vaut vraiment la peine de se doter de Nsight.</p>
          <p>Je suis sûr que d’autres logiciels méritent d’être mentionnés (comme <a class="lienArticle https" href="https://github.com/ValveSoftware/vogl">VOGL</a> de Valve et <a class="lienArticle https" href="https://apitrace.github.io/" target="_blank">APItrace</a>), mais cette courte liste vous donne déjà beaucoup d’outils à essayer. Je ne suis pas un expert avec ces outils, dîtes-moi dans les commentaires si je me trompe quelque part et je corrigerai où ce sera nécessaire. </p>
        </div>
      </div>
      
		<h2 class="TitreSection1" id="LI-G">I-G. Ressources supplémentaires<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <ul class="ListeDVP">
          <li><a class="lienArticle simple" href="http://retokoradi.com/2014/04/21/opengl-why-is-your-code-producing-a-black-window/" target="_blank">Pourquoi votre code donne-t-il une fenêtre noire ?</a> : liste des causes principales sur le fait que l’application n’affiche rien, par Reto Koradi.</li>
          <li><a class="lienArticle simple" href="http://vallentinsource.com/opengl/debug-output" target="_blank">Debug Output</a> : un article approfondi sur la sortie de débogage avec des informations détaillées sur la mise en place d’un contexte de débogage des systèmes multifenêtrés, par Vallentin Source.</li>
        </ul>
      </div>
      
		<h2 class="TitreSection1" id="LI-H">I-H. Remerciements<a class="HautPage" href="#" title="Haut de page">&#9650;</a></h2><div class="BlocSection1">
        
        <p>Ce tutoriel est une traduction réalisée par Jean-Michel Fray dont l’original a été écrit par Joey de Vries et qui est disponible sur le site <a class="lienArticle https" href="https://learnopengl.com/In-Practice/Debugging">Learn OpenGL</a>.</p>
      </div>
    </div>
  
<div class="cachee"><div class="barreNavigation"><hr class="hr-separation"/><a class="lientelechargement" href="sommaire.html"><img title="Page précédente" alt="précédent" src="./images/kitprecedent.png"/></a><a class="lientelechargement" href="sommaire.html"><img title="Revenir au sommaire" alt="sommaire" src="./images/kitsommaire.png"/></a><a class="lientelechargement" href="affichage-de-texte.html"><img alt="suivant" title="Page suivante" src="./images/kitsuivant.png"/></a><hr class="hr-separation"/></div></div></section></section>
  
	
  
  
  
  
  
  
  
  <section class="ArticleHorsLigne"><section class="SectionNoteBasPage articleBody"><hr class="hr-separation clear"/></section></section>
  
<p class="licence">Les sources présentées sur cette page sont libres de droits et vous pouvez les utiliser à votre convenance. Par contre, la page de présentation constitue une &oelig;uvre intellectuelle protégée par les droits d'auteur. Copyright &copy;2018 Joey de Vries.
				Aucune reproduction, même partielle, ne peut être faite de ce site et de l'ensemble de son contenu :
			textes, documents, images, etc. sans l'autorisation expresse de l'auteur. Sinon vous encourez selon la loi jusqu'à trois ans de prison et jusqu'à 300 000 € de dommages et intérêts.</p>
    </article>

<footer class="layout" role="contentinfo">				
  <div id="gabarit_footer">
		<div id="gabarit_footer_right">&nbsp;</div>
		<div id="gabarit_footer_left">&nbsp;</div>
		
		<p id="responsable">			
			<strong>Responsable des outils : Developpez.com</strong>
			 - <a href="https://www.developpez.net/forums/">Contacter par le forum</a>
		</p>
	</div>
	
  <div id="gabarit_pied">
  	<div id="gabarit_pied_right">&nbsp;</div>
  
  	<div id="gabarit_pied_left">&nbsp;</div>
  
  	<div id="gabarit_pied_contenu_superieur">
  	<div id="gabarit_pied_contenu">
  		<div class="gabarit_pied_div">
  			<span>Developpez.com</span>
  			<p><a href="https://club.developpez.com/contacts/">Nous contacter</a></p>
  			<p><a href="https://www.developpez.com/participez/">Participez</a></p>
  			<p><a href="https://www.developpez.com/legal/">Informations légales</a></p>
  		</div>
  		<div class="gabarit_pied_div_separation">&nbsp;</div>
  		<div class="gabarit_pied_div">
  			<span>Services</span>
  			<p><a onclick="window.open(this.href); return false;" href="https://www.developpez.net/forums/f552/hardware-systemes-logiciels/">Forum Systèmes</a></p>
  			<p><a href="https://blog.developpez.com/">Blogs</a></p>
  			<p><a href="https://www.developpez.com/hebergement/">Hébergement</a></p>
  		</div>
  		<div class="gabarit_pied_div_separation">&nbsp;</div>
  		<div class="gabarit_pied_div">
  			<span>Partenaires</span>
  			<p><a target="_blank" href="http://www.planethoster.net/">Hébergement Web</a></p>
  		</div>
  		<div style="clear: both;"></div>
  		<div id="gabarit_pied_copyright">
  			<p>Copyright &copy; 2000-2018 - www.developpez.com</p>
  		</div>
  	</div>
  	</div>
  </div>

</footer>
  </body>
</html>

		